// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pmgpie_cluster.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_pmgpie_5fcluster_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_pmgpie_5fcluster_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_pmgpie_5fcluster_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_pmgpie_5fcluster_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_pmgpie_5fcluster_2eproto;
namespace pmgpie_cluster {
class ClientMessage;
struct ClientMessageDefaultTypeInternal;
extern ClientMessageDefaultTypeInternal _ClientMessage_default_instance_;
class DispatchWorkUnit;
struct DispatchWorkUnitDefaultTypeInternal;
extern DispatchWorkUnitDefaultTypeInternal _DispatchWorkUnit_default_instance_;
class GoodBye;
struct GoodByeDefaultTypeInternal;
extern GoodByeDefaultTypeInternal _GoodBye_default_instance_;
class Helo;
struct HeloDefaultTypeInternal;
extern HeloDefaultTypeInternal _Helo_default_instance_;
class RequestWorkUnit;
struct RequestWorkUnitDefaultTypeInternal;
extern RequestWorkUnitDefaultTypeInternal _RequestWorkUnit_default_instance_;
class ServerMessage;
struct ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
class WorkUnitResult;
struct WorkUnitResultDefaultTypeInternal;
extern WorkUnitResultDefaultTypeInternal _WorkUnitResult_default_instance_;
}  // namespace pmgpie_cluster
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace pmgpie_cluster {

// ===================================================================


// -------------------------------------------------------------------

class WorkUnitResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pmgpie_cluster.WorkUnitResult) */ {
 public:
  inline WorkUnitResult() : WorkUnitResult(nullptr) {}
  ~WorkUnitResult() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorkUnitResult(::google::protobuf::internal::ConstantInitialized);

  inline WorkUnitResult(const WorkUnitResult& from)
      : WorkUnitResult(nullptr, from) {}
  WorkUnitResult(WorkUnitResult&& from) noexcept
    : WorkUnitResult() {
    *this = ::std::move(from);
  }

  inline WorkUnitResult& operator=(const WorkUnitResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkUnitResult& operator=(WorkUnitResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkUnitResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkUnitResult* internal_default_instance() {
    return reinterpret_cast<const WorkUnitResult*>(
               &_WorkUnitResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(WorkUnitResult& a, WorkUnitResult& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkUnitResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkUnitResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkUnitResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkUnitResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkUnitResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorkUnitResult& from) {
    WorkUnitResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorkUnitResult* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pmgpie_cluster.WorkUnitResult";
  }
  protected:
  explicit WorkUnitResult(::google::protobuf::Arena* arena);
  WorkUnitResult(::google::protobuf::Arena* arena, const WorkUnitResult& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDigitsFieldNumber = 2,
    kStartFieldNumber = 1,
  };
  // string digits = 2;
  void clear_digits() ;
  const std::string& digits() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_digits(Arg_&& arg, Args_... args);
  std::string* mutable_digits();
  PROTOBUF_NODISCARD std::string* release_digits();
  void set_allocated_digits(std::string* value);

  private:
  const std::string& _internal_digits() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digits(
      const std::string& value);
  std::string* _internal_mutable_digits();

  public:
  // uint64 start = 1;
  void clear_start() ;
  ::uint64_t start() const;
  void set_start(::uint64_t value);

  private:
  ::uint64_t _internal_start() const;
  void _internal_set_start(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pmgpie_cluster.WorkUnitResult)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr digits_;
    ::uint64_t start_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmgpie_5fcluster_2eproto;
};// -------------------------------------------------------------------

class RequestWorkUnit final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:pmgpie_cluster.RequestWorkUnit) */ {
 public:
  inline RequestWorkUnit() : RequestWorkUnit(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestWorkUnit(::google::protobuf::internal::ConstantInitialized);

  inline RequestWorkUnit(const RequestWorkUnit& from)
      : RequestWorkUnit(nullptr, from) {}
  RequestWorkUnit(RequestWorkUnit&& from) noexcept
    : RequestWorkUnit() {
    *this = ::std::move(from);
  }

  inline RequestWorkUnit& operator=(const RequestWorkUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestWorkUnit& operator=(RequestWorkUnit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestWorkUnit& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestWorkUnit* internal_default_instance() {
    return reinterpret_cast<const RequestWorkUnit*>(
               &_RequestWorkUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RequestWorkUnit& a, RequestWorkUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestWorkUnit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestWorkUnit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestWorkUnit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestWorkUnit>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RequestWorkUnit& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RequestWorkUnit& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pmgpie_cluster.RequestWorkUnit";
  }
  protected:
  explicit RequestWorkUnit(::google::protobuf::Arena* arena);
  RequestWorkUnit(::google::protobuf::Arena* arena, const RequestWorkUnit& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pmgpie_cluster.RequestWorkUnit)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_pmgpie_5fcluster_2eproto;
};// -------------------------------------------------------------------

class Helo final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:pmgpie_cluster.Helo) */ {
 public:
  inline Helo() : Helo(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Helo(::google::protobuf::internal::ConstantInitialized);

  inline Helo(const Helo& from)
      : Helo(nullptr, from) {}
  Helo(Helo&& from) noexcept
    : Helo() {
    *this = ::std::move(from);
  }

  inline Helo& operator=(const Helo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Helo& operator=(Helo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Helo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Helo* internal_default_instance() {
    return reinterpret_cast<const Helo*>(
               &_Helo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Helo& a, Helo& b) {
    a.Swap(&b);
  }
  inline void Swap(Helo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Helo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Helo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Helo>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Helo& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Helo& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pmgpie_cluster.Helo";
  }
  protected:
  explicit Helo(::google::protobuf::Arena* arena);
  Helo(::google::protobuf::Arena* arena, const Helo& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pmgpie_cluster.Helo)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_pmgpie_5fcluster_2eproto;
};// -------------------------------------------------------------------

class GoodBye final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:pmgpie_cluster.GoodBye) */ {
 public:
  inline GoodBye() : GoodBye(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GoodBye(::google::protobuf::internal::ConstantInitialized);

  inline GoodBye(const GoodBye& from)
      : GoodBye(nullptr, from) {}
  GoodBye(GoodBye&& from) noexcept
    : GoodBye() {
    *this = ::std::move(from);
  }

  inline GoodBye& operator=(const GoodBye& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoodBye& operator=(GoodBye&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoodBye& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoodBye* internal_default_instance() {
    return reinterpret_cast<const GoodBye*>(
               &_GoodBye_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GoodBye& a, GoodBye& b) {
    a.Swap(&b);
  }
  inline void Swap(GoodBye* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoodBye* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoodBye* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GoodBye>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GoodBye& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GoodBye& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pmgpie_cluster.GoodBye";
  }
  protected:
  explicit GoodBye(::google::protobuf::Arena* arena);
  GoodBye(::google::protobuf::Arena* arena, const GoodBye& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pmgpie_cluster.GoodBye)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_pmgpie_5fcluster_2eproto;
};// -------------------------------------------------------------------

class DispatchWorkUnit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pmgpie_cluster.DispatchWorkUnit) */ {
 public:
  inline DispatchWorkUnit() : DispatchWorkUnit(nullptr) {}
  ~DispatchWorkUnit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DispatchWorkUnit(::google::protobuf::internal::ConstantInitialized);

  inline DispatchWorkUnit(const DispatchWorkUnit& from)
      : DispatchWorkUnit(nullptr, from) {}
  DispatchWorkUnit(DispatchWorkUnit&& from) noexcept
    : DispatchWorkUnit() {
    *this = ::std::move(from);
  }

  inline DispatchWorkUnit& operator=(const DispatchWorkUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline DispatchWorkUnit& operator=(DispatchWorkUnit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DispatchWorkUnit& default_instance() {
    return *internal_default_instance();
  }
  static inline const DispatchWorkUnit* internal_default_instance() {
    return reinterpret_cast<const DispatchWorkUnit*>(
               &_DispatchWorkUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DispatchWorkUnit& a, DispatchWorkUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(DispatchWorkUnit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DispatchWorkUnit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DispatchWorkUnit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DispatchWorkUnit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DispatchWorkUnit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DispatchWorkUnit& from) {
    DispatchWorkUnit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DispatchWorkUnit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pmgpie_cluster.DispatchWorkUnit";
  }
  protected:
  explicit DispatchWorkUnit(::google::protobuf::Arena* arena);
  DispatchWorkUnit(::google::protobuf::Arena* arena, const DispatchWorkUnit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kNDigitsFieldNumber = 2,
  };
  // uint64 start = 1;
  void clear_start() ;
  ::uint64_t start() const;
  void set_start(::uint64_t value);

  private:
  ::uint64_t _internal_start() const;
  void _internal_set_start(::uint64_t value);

  public:
  // uint32 n_digits = 2;
  void clear_n_digits() ;
  ::uint32_t n_digits() const;
  void set_n_digits(::uint32_t value);

  private:
  ::uint32_t _internal_n_digits() const;
  void _internal_set_n_digits(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pmgpie_cluster.DispatchWorkUnit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t start_;
    ::uint32_t n_digits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmgpie_5fcluster_2eproto;
};// -------------------------------------------------------------------

class ServerMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pmgpie_cluster.ServerMessage) */ {
 public:
  inline ServerMessage() : ServerMessage(nullptr) {}
  ~ServerMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ServerMessage(::google::protobuf::internal::ConstantInitialized);

  inline ServerMessage(const ServerMessage& from)
      : ServerMessage(nullptr, from) {}
  ServerMessage(ServerMessage&& from) noexcept
    : ServerMessage() {
    *this = ::std::move(from);
  }

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMessage& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kGoodbye = 1,
    kDispatchworkunit = 2,
    BODY_NOT_SET = 0,
  };

  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
               &_ServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ServerMessage& a, ServerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServerMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ServerMessage& from) {
    ServerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ServerMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pmgpie_cluster.ServerMessage";
  }
  protected:
  explicit ServerMessage(::google::protobuf::Arena* arena);
  ServerMessage(::google::protobuf::Arena* arena, const ServerMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoodbyeFieldNumber = 1,
    kDispatchworkunitFieldNumber = 2,
  };
  // .pmgpie_cluster.GoodBye goodbye = 1;
  bool has_goodbye() const;
  private:
  bool _internal_has_goodbye() const;

  public:
  void clear_goodbye() ;
  const ::pmgpie_cluster::GoodBye& goodbye() const;
  PROTOBUF_NODISCARD ::pmgpie_cluster::GoodBye* release_goodbye();
  ::pmgpie_cluster::GoodBye* mutable_goodbye();
  void set_allocated_goodbye(::pmgpie_cluster::GoodBye* value);
  void unsafe_arena_set_allocated_goodbye(::pmgpie_cluster::GoodBye* value);
  ::pmgpie_cluster::GoodBye* unsafe_arena_release_goodbye();

  private:
  const ::pmgpie_cluster::GoodBye& _internal_goodbye() const;
  ::pmgpie_cluster::GoodBye* _internal_mutable_goodbye();

  public:
  // .pmgpie_cluster.DispatchWorkUnit dispatchworkunit = 2;
  bool has_dispatchworkunit() const;
  private:
  bool _internal_has_dispatchworkunit() const;

  public:
  void clear_dispatchworkunit() ;
  const ::pmgpie_cluster::DispatchWorkUnit& dispatchworkunit() const;
  PROTOBUF_NODISCARD ::pmgpie_cluster::DispatchWorkUnit* release_dispatchworkunit();
  ::pmgpie_cluster::DispatchWorkUnit* mutable_dispatchworkunit();
  void set_allocated_dispatchworkunit(::pmgpie_cluster::DispatchWorkUnit* value);
  void unsafe_arena_set_allocated_dispatchworkunit(::pmgpie_cluster::DispatchWorkUnit* value);
  ::pmgpie_cluster::DispatchWorkUnit* unsafe_arena_release_dispatchworkunit();

  private:
  const ::pmgpie_cluster::DispatchWorkUnit& _internal_dispatchworkunit() const;
  ::pmgpie_cluster::DispatchWorkUnit* _internal_mutable_dispatchworkunit();

  public:
  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:pmgpie_cluster.ServerMessage)
 private:
  class _Internal;
  void set_has_goodbye();
  void set_has_dispatchworkunit();

  inline bool has_body() const;
  inline void clear_has_body();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::pmgpie_cluster::GoodBye* goodbye_;
      ::pmgpie_cluster::DispatchWorkUnit* dispatchworkunit_;
    } body_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmgpie_5fcluster_2eproto;
};// -------------------------------------------------------------------

class ClientMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pmgpie_cluster.ClientMessage) */ {
 public:
  inline ClientMessage() : ClientMessage(nullptr) {}
  ~ClientMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClientMessage(::google::protobuf::internal::ConstantInitialized);

  inline ClientMessage(const ClientMessage& from)
      : ClientMessage(nullptr, from) {}
  ClientMessage(ClientMessage&& from) noexcept
    : ClientMessage() {
    *this = ::std::move(from);
  }

  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientMessage& operator=(ClientMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientMessage& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kHelo = 2,
    kGoodbye = 3,
    kWorkunitresult = 4,
    kRequestworkunit = 5,
    BODY_NOT_SET = 0,
  };

  static inline const ClientMessage* internal_default_instance() {
    return reinterpret_cast<const ClientMessage*>(
               &_ClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ClientMessage& a, ClientMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClientMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ClientMessage& from) {
    ClientMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ClientMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pmgpie_cluster.ClientMessage";
  }
  protected:
  explicit ClientMessage(::google::protobuf::Arena* arena);
  ClientMessage(::google::protobuf::Arena* arena, const ClientMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkerIdFieldNumber = 1,
    kHeloFieldNumber = 2,
    kGoodbyeFieldNumber = 3,
    kWorkunitresultFieldNumber = 4,
    kRequestworkunitFieldNumber = 5,
  };
  // string worker_id = 1;
  void clear_worker_id() ;
  const std::string& worker_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_worker_id(Arg_&& arg, Args_... args);
  std::string* mutable_worker_id();
  PROTOBUF_NODISCARD std::string* release_worker_id();
  void set_allocated_worker_id(std::string* value);

  private:
  const std::string& _internal_worker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_id(
      const std::string& value);
  std::string* _internal_mutable_worker_id();

  public:
  // .pmgpie_cluster.Helo helo = 2;
  bool has_helo() const;
  private:
  bool _internal_has_helo() const;

  public:
  void clear_helo() ;
  const ::pmgpie_cluster::Helo& helo() const;
  PROTOBUF_NODISCARD ::pmgpie_cluster::Helo* release_helo();
  ::pmgpie_cluster::Helo* mutable_helo();
  void set_allocated_helo(::pmgpie_cluster::Helo* value);
  void unsafe_arena_set_allocated_helo(::pmgpie_cluster::Helo* value);
  ::pmgpie_cluster::Helo* unsafe_arena_release_helo();

  private:
  const ::pmgpie_cluster::Helo& _internal_helo() const;
  ::pmgpie_cluster::Helo* _internal_mutable_helo();

  public:
  // .pmgpie_cluster.GoodBye goodbye = 3;
  bool has_goodbye() const;
  private:
  bool _internal_has_goodbye() const;

  public:
  void clear_goodbye() ;
  const ::pmgpie_cluster::GoodBye& goodbye() const;
  PROTOBUF_NODISCARD ::pmgpie_cluster::GoodBye* release_goodbye();
  ::pmgpie_cluster::GoodBye* mutable_goodbye();
  void set_allocated_goodbye(::pmgpie_cluster::GoodBye* value);
  void unsafe_arena_set_allocated_goodbye(::pmgpie_cluster::GoodBye* value);
  ::pmgpie_cluster::GoodBye* unsafe_arena_release_goodbye();

  private:
  const ::pmgpie_cluster::GoodBye& _internal_goodbye() const;
  ::pmgpie_cluster::GoodBye* _internal_mutable_goodbye();

  public:
  // .pmgpie_cluster.WorkUnitResult workunitresult = 4;
  bool has_workunitresult() const;
  private:
  bool _internal_has_workunitresult() const;

  public:
  void clear_workunitresult() ;
  const ::pmgpie_cluster::WorkUnitResult& workunitresult() const;
  PROTOBUF_NODISCARD ::pmgpie_cluster::WorkUnitResult* release_workunitresult();
  ::pmgpie_cluster::WorkUnitResult* mutable_workunitresult();
  void set_allocated_workunitresult(::pmgpie_cluster::WorkUnitResult* value);
  void unsafe_arena_set_allocated_workunitresult(::pmgpie_cluster::WorkUnitResult* value);
  ::pmgpie_cluster::WorkUnitResult* unsafe_arena_release_workunitresult();

  private:
  const ::pmgpie_cluster::WorkUnitResult& _internal_workunitresult() const;
  ::pmgpie_cluster::WorkUnitResult* _internal_mutable_workunitresult();

  public:
  // .pmgpie_cluster.RequestWorkUnit requestworkunit = 5;
  bool has_requestworkunit() const;
  private:
  bool _internal_has_requestworkunit() const;

  public:
  void clear_requestworkunit() ;
  const ::pmgpie_cluster::RequestWorkUnit& requestworkunit() const;
  PROTOBUF_NODISCARD ::pmgpie_cluster::RequestWorkUnit* release_requestworkunit();
  ::pmgpie_cluster::RequestWorkUnit* mutable_requestworkunit();
  void set_allocated_requestworkunit(::pmgpie_cluster::RequestWorkUnit* value);
  void unsafe_arena_set_allocated_requestworkunit(::pmgpie_cluster::RequestWorkUnit* value);
  ::pmgpie_cluster::RequestWorkUnit* unsafe_arena_release_requestworkunit();

  private:
  const ::pmgpie_cluster::RequestWorkUnit& _internal_requestworkunit() const;
  ::pmgpie_cluster::RequestWorkUnit* _internal_mutable_requestworkunit();

  public:
  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:pmgpie_cluster.ClientMessage)
 private:
  class _Internal;
  void set_has_helo();
  void set_has_goodbye();
  void set_has_workunitresult();
  void set_has_requestworkunit();

  inline bool has_body() const;
  inline void clear_has_body();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 4,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr worker_id_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::pmgpie_cluster::Helo* helo_;
      ::pmgpie_cluster::GoodBye* goodbye_;
      ::pmgpie_cluster::WorkUnitResult* workunitresult_;
      ::pmgpie_cluster::RequestWorkUnit* requestworkunit_;
    } body_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmgpie_5fcluster_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ClientMessage

// string worker_id = 1;
inline void ClientMessage::clear_worker_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.worker_id_.ClearToEmpty();
}
inline const std::string& ClientMessage::worker_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pmgpie_cluster.ClientMessage.worker_id)
  return _internal_worker_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientMessage::set_worker_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.worker_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pmgpie_cluster.ClientMessage.worker_id)
}
inline std::string* ClientMessage::mutable_worker_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_worker_id();
  // @@protoc_insertion_point(field_mutable:pmgpie_cluster.ClientMessage.worker_id)
  return _s;
}
inline const std::string& ClientMessage::_internal_worker_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.worker_id_.Get();
}
inline void ClientMessage::_internal_set_worker_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.worker_id_.Set(value, GetArena());
}
inline std::string* ClientMessage::_internal_mutable_worker_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.worker_id_.Mutable( GetArena());
}
inline std::string* ClientMessage::release_worker_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pmgpie_cluster.ClientMessage.worker_id)
  return _impl_.worker_id_.Release();
}
inline void ClientMessage::set_allocated_worker_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.worker_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.worker_id_.IsDefault()) {
          _impl_.worker_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pmgpie_cluster.ClientMessage.worker_id)
}

// .pmgpie_cluster.Helo helo = 2;
inline bool ClientMessage::has_helo() const {
  return body_case() == kHelo;
}
inline bool ClientMessage::_internal_has_helo() const {
  return body_case() == kHelo;
}
inline void ClientMessage::set_has_helo() {
  _impl_._oneof_case_[0] = kHelo;
}
inline void ClientMessage::clear_helo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (body_case() == kHelo) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.helo_;
    }
    clear_has_body();
  }
}
inline ::pmgpie_cluster::Helo* ClientMessage::release_helo() {
  // @@protoc_insertion_point(field_release:pmgpie_cluster.ClientMessage.helo)
  if (body_case() == kHelo) {
    clear_has_body();
    auto* temp = _impl_.body_.helo_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.helo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pmgpie_cluster::Helo& ClientMessage::_internal_helo() const {
  return body_case() == kHelo ? *_impl_.body_.helo_ : reinterpret_cast<::pmgpie_cluster::Helo&>(::pmgpie_cluster::_Helo_default_instance_);
}
inline const ::pmgpie_cluster::Helo& ClientMessage::helo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pmgpie_cluster.ClientMessage.helo)
  return _internal_helo();
}
inline ::pmgpie_cluster::Helo* ClientMessage::unsafe_arena_release_helo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pmgpie_cluster.ClientMessage.helo)
  if (body_case() == kHelo) {
    clear_has_body();
    auto* temp = _impl_.body_.helo_;
    _impl_.body_.helo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_helo(::pmgpie_cluster::Helo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_helo();
    _impl_.body_.helo_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pmgpie_cluster.ClientMessage.helo)
}
inline ::pmgpie_cluster::Helo* ClientMessage::_internal_mutable_helo() {
  if (body_case() != kHelo) {
    clear_body();
    set_has_helo();
    _impl_.body_.helo_ = CreateMaybeMessage<::pmgpie_cluster::Helo>(GetArena());
  }
  return _impl_.body_.helo_;
}
inline ::pmgpie_cluster::Helo* ClientMessage::mutable_helo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pmgpie_cluster::Helo* _msg = _internal_mutable_helo();
  // @@protoc_insertion_point(field_mutable:pmgpie_cluster.ClientMessage.helo)
  return _msg;
}

// .pmgpie_cluster.GoodBye goodbye = 3;
inline bool ClientMessage::has_goodbye() const {
  return body_case() == kGoodbye;
}
inline bool ClientMessage::_internal_has_goodbye() const {
  return body_case() == kGoodbye;
}
inline void ClientMessage::set_has_goodbye() {
  _impl_._oneof_case_[0] = kGoodbye;
}
inline void ClientMessage::clear_goodbye() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (body_case() == kGoodbye) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.goodbye_;
    }
    clear_has_body();
  }
}
inline ::pmgpie_cluster::GoodBye* ClientMessage::release_goodbye() {
  // @@protoc_insertion_point(field_release:pmgpie_cluster.ClientMessage.goodbye)
  if (body_case() == kGoodbye) {
    clear_has_body();
    auto* temp = _impl_.body_.goodbye_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.goodbye_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pmgpie_cluster::GoodBye& ClientMessage::_internal_goodbye() const {
  return body_case() == kGoodbye ? *_impl_.body_.goodbye_ : reinterpret_cast<::pmgpie_cluster::GoodBye&>(::pmgpie_cluster::_GoodBye_default_instance_);
}
inline const ::pmgpie_cluster::GoodBye& ClientMessage::goodbye() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pmgpie_cluster.ClientMessage.goodbye)
  return _internal_goodbye();
}
inline ::pmgpie_cluster::GoodBye* ClientMessage::unsafe_arena_release_goodbye() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pmgpie_cluster.ClientMessage.goodbye)
  if (body_case() == kGoodbye) {
    clear_has_body();
    auto* temp = _impl_.body_.goodbye_;
    _impl_.body_.goodbye_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_goodbye(::pmgpie_cluster::GoodBye* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_goodbye();
    _impl_.body_.goodbye_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pmgpie_cluster.ClientMessage.goodbye)
}
inline ::pmgpie_cluster::GoodBye* ClientMessage::_internal_mutable_goodbye() {
  if (body_case() != kGoodbye) {
    clear_body();
    set_has_goodbye();
    _impl_.body_.goodbye_ = CreateMaybeMessage<::pmgpie_cluster::GoodBye>(GetArena());
  }
  return _impl_.body_.goodbye_;
}
inline ::pmgpie_cluster::GoodBye* ClientMessage::mutable_goodbye() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pmgpie_cluster::GoodBye* _msg = _internal_mutable_goodbye();
  // @@protoc_insertion_point(field_mutable:pmgpie_cluster.ClientMessage.goodbye)
  return _msg;
}

// .pmgpie_cluster.WorkUnitResult workunitresult = 4;
inline bool ClientMessage::has_workunitresult() const {
  return body_case() == kWorkunitresult;
}
inline bool ClientMessage::_internal_has_workunitresult() const {
  return body_case() == kWorkunitresult;
}
inline void ClientMessage::set_has_workunitresult() {
  _impl_._oneof_case_[0] = kWorkunitresult;
}
inline void ClientMessage::clear_workunitresult() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (body_case() == kWorkunitresult) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.workunitresult_;
    }
    clear_has_body();
  }
}
inline ::pmgpie_cluster::WorkUnitResult* ClientMessage::release_workunitresult() {
  // @@protoc_insertion_point(field_release:pmgpie_cluster.ClientMessage.workunitresult)
  if (body_case() == kWorkunitresult) {
    clear_has_body();
    auto* temp = _impl_.body_.workunitresult_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.workunitresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pmgpie_cluster::WorkUnitResult& ClientMessage::_internal_workunitresult() const {
  return body_case() == kWorkunitresult ? *_impl_.body_.workunitresult_ : reinterpret_cast<::pmgpie_cluster::WorkUnitResult&>(::pmgpie_cluster::_WorkUnitResult_default_instance_);
}
inline const ::pmgpie_cluster::WorkUnitResult& ClientMessage::workunitresult() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pmgpie_cluster.ClientMessage.workunitresult)
  return _internal_workunitresult();
}
inline ::pmgpie_cluster::WorkUnitResult* ClientMessage::unsafe_arena_release_workunitresult() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pmgpie_cluster.ClientMessage.workunitresult)
  if (body_case() == kWorkunitresult) {
    clear_has_body();
    auto* temp = _impl_.body_.workunitresult_;
    _impl_.body_.workunitresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_workunitresult(::pmgpie_cluster::WorkUnitResult* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_workunitresult();
    _impl_.body_.workunitresult_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pmgpie_cluster.ClientMessage.workunitresult)
}
inline ::pmgpie_cluster::WorkUnitResult* ClientMessage::_internal_mutable_workunitresult() {
  if (body_case() != kWorkunitresult) {
    clear_body();
    set_has_workunitresult();
    _impl_.body_.workunitresult_ = CreateMaybeMessage<::pmgpie_cluster::WorkUnitResult>(GetArena());
  }
  return _impl_.body_.workunitresult_;
}
inline ::pmgpie_cluster::WorkUnitResult* ClientMessage::mutable_workunitresult() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pmgpie_cluster::WorkUnitResult* _msg = _internal_mutable_workunitresult();
  // @@protoc_insertion_point(field_mutable:pmgpie_cluster.ClientMessage.workunitresult)
  return _msg;
}

// .pmgpie_cluster.RequestWorkUnit requestworkunit = 5;
inline bool ClientMessage::has_requestworkunit() const {
  return body_case() == kRequestworkunit;
}
inline bool ClientMessage::_internal_has_requestworkunit() const {
  return body_case() == kRequestworkunit;
}
inline void ClientMessage::set_has_requestworkunit() {
  _impl_._oneof_case_[0] = kRequestworkunit;
}
inline void ClientMessage::clear_requestworkunit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (body_case() == kRequestworkunit) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.requestworkunit_;
    }
    clear_has_body();
  }
}
inline ::pmgpie_cluster::RequestWorkUnit* ClientMessage::release_requestworkunit() {
  // @@protoc_insertion_point(field_release:pmgpie_cluster.ClientMessage.requestworkunit)
  if (body_case() == kRequestworkunit) {
    clear_has_body();
    auto* temp = _impl_.body_.requestworkunit_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.requestworkunit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pmgpie_cluster::RequestWorkUnit& ClientMessage::_internal_requestworkunit() const {
  return body_case() == kRequestworkunit ? *_impl_.body_.requestworkunit_ : reinterpret_cast<::pmgpie_cluster::RequestWorkUnit&>(::pmgpie_cluster::_RequestWorkUnit_default_instance_);
}
inline const ::pmgpie_cluster::RequestWorkUnit& ClientMessage::requestworkunit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pmgpie_cluster.ClientMessage.requestworkunit)
  return _internal_requestworkunit();
}
inline ::pmgpie_cluster::RequestWorkUnit* ClientMessage::unsafe_arena_release_requestworkunit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pmgpie_cluster.ClientMessage.requestworkunit)
  if (body_case() == kRequestworkunit) {
    clear_has_body();
    auto* temp = _impl_.body_.requestworkunit_;
    _impl_.body_.requestworkunit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_requestworkunit(::pmgpie_cluster::RequestWorkUnit* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_requestworkunit();
    _impl_.body_.requestworkunit_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pmgpie_cluster.ClientMessage.requestworkunit)
}
inline ::pmgpie_cluster::RequestWorkUnit* ClientMessage::_internal_mutable_requestworkunit() {
  if (body_case() != kRequestworkunit) {
    clear_body();
    set_has_requestworkunit();
    _impl_.body_.requestworkunit_ = CreateMaybeMessage<::pmgpie_cluster::RequestWorkUnit>(GetArena());
  }
  return _impl_.body_.requestworkunit_;
}
inline ::pmgpie_cluster::RequestWorkUnit* ClientMessage::mutable_requestworkunit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pmgpie_cluster::RequestWorkUnit* _msg = _internal_mutable_requestworkunit();
  // @@protoc_insertion_point(field_mutable:pmgpie_cluster.ClientMessage.requestworkunit)
  return _msg;
}

inline bool ClientMessage::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void ClientMessage::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline ClientMessage::BodyCase ClientMessage::body_case() const {
  return ClientMessage::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerMessage

// .pmgpie_cluster.GoodBye goodbye = 1;
inline bool ServerMessage::has_goodbye() const {
  return body_case() == kGoodbye;
}
inline bool ServerMessage::_internal_has_goodbye() const {
  return body_case() == kGoodbye;
}
inline void ServerMessage::set_has_goodbye() {
  _impl_._oneof_case_[0] = kGoodbye;
}
inline void ServerMessage::clear_goodbye() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (body_case() == kGoodbye) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.goodbye_;
    }
    clear_has_body();
  }
}
inline ::pmgpie_cluster::GoodBye* ServerMessage::release_goodbye() {
  // @@protoc_insertion_point(field_release:pmgpie_cluster.ServerMessage.goodbye)
  if (body_case() == kGoodbye) {
    clear_has_body();
    auto* temp = _impl_.body_.goodbye_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.goodbye_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pmgpie_cluster::GoodBye& ServerMessage::_internal_goodbye() const {
  return body_case() == kGoodbye ? *_impl_.body_.goodbye_ : reinterpret_cast<::pmgpie_cluster::GoodBye&>(::pmgpie_cluster::_GoodBye_default_instance_);
}
inline const ::pmgpie_cluster::GoodBye& ServerMessage::goodbye() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pmgpie_cluster.ServerMessage.goodbye)
  return _internal_goodbye();
}
inline ::pmgpie_cluster::GoodBye* ServerMessage::unsafe_arena_release_goodbye() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pmgpie_cluster.ServerMessage.goodbye)
  if (body_case() == kGoodbye) {
    clear_has_body();
    auto* temp = _impl_.body_.goodbye_;
    _impl_.body_.goodbye_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_goodbye(::pmgpie_cluster::GoodBye* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_goodbye();
    _impl_.body_.goodbye_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pmgpie_cluster.ServerMessage.goodbye)
}
inline ::pmgpie_cluster::GoodBye* ServerMessage::_internal_mutable_goodbye() {
  if (body_case() != kGoodbye) {
    clear_body();
    set_has_goodbye();
    _impl_.body_.goodbye_ = CreateMaybeMessage<::pmgpie_cluster::GoodBye>(GetArena());
  }
  return _impl_.body_.goodbye_;
}
inline ::pmgpie_cluster::GoodBye* ServerMessage::mutable_goodbye() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pmgpie_cluster::GoodBye* _msg = _internal_mutable_goodbye();
  // @@protoc_insertion_point(field_mutable:pmgpie_cluster.ServerMessage.goodbye)
  return _msg;
}

// .pmgpie_cluster.DispatchWorkUnit dispatchworkunit = 2;
inline bool ServerMessage::has_dispatchworkunit() const {
  return body_case() == kDispatchworkunit;
}
inline bool ServerMessage::_internal_has_dispatchworkunit() const {
  return body_case() == kDispatchworkunit;
}
inline void ServerMessage::set_has_dispatchworkunit() {
  _impl_._oneof_case_[0] = kDispatchworkunit;
}
inline void ServerMessage::clear_dispatchworkunit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (body_case() == kDispatchworkunit) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.dispatchworkunit_;
    }
    clear_has_body();
  }
}
inline ::pmgpie_cluster::DispatchWorkUnit* ServerMessage::release_dispatchworkunit() {
  // @@protoc_insertion_point(field_release:pmgpie_cluster.ServerMessage.dispatchworkunit)
  if (body_case() == kDispatchworkunit) {
    clear_has_body();
    auto* temp = _impl_.body_.dispatchworkunit_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.dispatchworkunit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pmgpie_cluster::DispatchWorkUnit& ServerMessage::_internal_dispatchworkunit() const {
  return body_case() == kDispatchworkunit ? *_impl_.body_.dispatchworkunit_ : reinterpret_cast<::pmgpie_cluster::DispatchWorkUnit&>(::pmgpie_cluster::_DispatchWorkUnit_default_instance_);
}
inline const ::pmgpie_cluster::DispatchWorkUnit& ServerMessage::dispatchworkunit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pmgpie_cluster.ServerMessage.dispatchworkunit)
  return _internal_dispatchworkunit();
}
inline ::pmgpie_cluster::DispatchWorkUnit* ServerMessage::unsafe_arena_release_dispatchworkunit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pmgpie_cluster.ServerMessage.dispatchworkunit)
  if (body_case() == kDispatchworkunit) {
    clear_has_body();
    auto* temp = _impl_.body_.dispatchworkunit_;
    _impl_.body_.dispatchworkunit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_dispatchworkunit(::pmgpie_cluster::DispatchWorkUnit* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_dispatchworkunit();
    _impl_.body_.dispatchworkunit_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pmgpie_cluster.ServerMessage.dispatchworkunit)
}
inline ::pmgpie_cluster::DispatchWorkUnit* ServerMessage::_internal_mutable_dispatchworkunit() {
  if (body_case() != kDispatchworkunit) {
    clear_body();
    set_has_dispatchworkunit();
    _impl_.body_.dispatchworkunit_ = CreateMaybeMessage<::pmgpie_cluster::DispatchWorkUnit>(GetArena());
  }
  return _impl_.body_.dispatchworkunit_;
}
inline ::pmgpie_cluster::DispatchWorkUnit* ServerMessage::mutable_dispatchworkunit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pmgpie_cluster::DispatchWorkUnit* _msg = _internal_mutable_dispatchworkunit();
  // @@protoc_insertion_point(field_mutable:pmgpie_cluster.ServerMessage.dispatchworkunit)
  return _msg;
}

inline bool ServerMessage::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void ServerMessage::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline ServerMessage::BodyCase ServerMessage::body_case() const {
  return ServerMessage::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Helo

// -------------------------------------------------------------------

// WorkUnitResult

// uint64 start = 1;
inline void WorkUnitResult::clear_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_ = ::uint64_t{0u};
}
inline ::uint64_t WorkUnitResult::start() const {
  // @@protoc_insertion_point(field_get:pmgpie_cluster.WorkUnitResult.start)
  return _internal_start();
}
inline void WorkUnitResult::set_start(::uint64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:pmgpie_cluster.WorkUnitResult.start)
}
inline ::uint64_t WorkUnitResult::_internal_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_;
}
inline void WorkUnitResult::_internal_set_start(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_ = value;
}

// string digits = 2;
inline void WorkUnitResult::clear_digits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.digits_.ClearToEmpty();
}
inline const std::string& WorkUnitResult::digits() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pmgpie_cluster.WorkUnitResult.digits)
  return _internal_digits();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorkUnitResult::set_digits(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.digits_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pmgpie_cluster.WorkUnitResult.digits)
}
inline std::string* WorkUnitResult::mutable_digits() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_digits();
  // @@protoc_insertion_point(field_mutable:pmgpie_cluster.WorkUnitResult.digits)
  return _s;
}
inline const std::string& WorkUnitResult::_internal_digits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.digits_.Get();
}
inline void WorkUnitResult::_internal_set_digits(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.digits_.Set(value, GetArena());
}
inline std::string* WorkUnitResult::_internal_mutable_digits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.digits_.Mutable( GetArena());
}
inline std::string* WorkUnitResult::release_digits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pmgpie_cluster.WorkUnitResult.digits)
  return _impl_.digits_.Release();
}
inline void WorkUnitResult::set_allocated_digits(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.digits_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.digits_.IsDefault()) {
          _impl_.digits_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pmgpie_cluster.WorkUnitResult.digits)
}

// -------------------------------------------------------------------

// RequestWorkUnit

// -------------------------------------------------------------------

// DispatchWorkUnit

// uint64 start = 1;
inline void DispatchWorkUnit::clear_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_ = ::uint64_t{0u};
}
inline ::uint64_t DispatchWorkUnit::start() const {
  // @@protoc_insertion_point(field_get:pmgpie_cluster.DispatchWorkUnit.start)
  return _internal_start();
}
inline void DispatchWorkUnit::set_start(::uint64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:pmgpie_cluster.DispatchWorkUnit.start)
}
inline ::uint64_t DispatchWorkUnit::_internal_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_;
}
inline void DispatchWorkUnit::_internal_set_start(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_ = value;
}

// uint32 n_digits = 2;
inline void DispatchWorkUnit::clear_n_digits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.n_digits_ = 0u;
}
inline ::uint32_t DispatchWorkUnit::n_digits() const {
  // @@protoc_insertion_point(field_get:pmgpie_cluster.DispatchWorkUnit.n_digits)
  return _internal_n_digits();
}
inline void DispatchWorkUnit::set_n_digits(::uint32_t value) {
  _internal_set_n_digits(value);
  // @@protoc_insertion_point(field_set:pmgpie_cluster.DispatchWorkUnit.n_digits)
}
inline ::uint32_t DispatchWorkUnit::_internal_n_digits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.n_digits_;
}
inline void DispatchWorkUnit::_internal_set_n_digits(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.n_digits_ = value;
}

// -------------------------------------------------------------------

// GoodBye

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace pmgpie_cluster


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_pmgpie_5fcluster_2eproto_2epb_2eh
